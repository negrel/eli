#!/usr/bin/env bash

parent_dir="$(dirname $(readlink -e $0))"

source "$ELI_PATH/lib/log"
source "$ELI_PATH/lib/traps"

set -e
trap exit_trap EXIT

function print_help {
  cat <<EOF
Install the given image onto the system

USAGE:
  eli [global options] install image_name1 image_name2 [options]

OPTIONS:
  -h, --help                 print this menu
  -i, --initramfs-dest       destination of the initramfs, if empty the creation
                             of the initramfs is skipped (default: /boot)
  -d, --squashfs-dest        destination of the root squashfs filesystem, if empty
                             the creation of the squashfs is skipped (default: '')
  -l, --resize-lvm           prevent root lvm logical volume resize (default: false)
  -f, --force                apply --force flag on lvm and other command (default: false)
EOF
}

function clean_install {
  exit_code="$?"
  log="log_info"
  if [ "$exit_code" != "0" ]; then
    log="log_error"

    log_error "exit code $exit_code trapped, cleaning install..."
  fi

  # Clean container if it exist
  if [ "buildah inspect $1" != "0" ];  then
    log_info "unmounting container $ctr..."
    buildah umount "$1"
    log_info "container $ctr unmounted"

    log_info "removing container $ctr..."
    buildah rm "$1"
    log_info "container $ctr removed"
  fi

  "$log" "install cleaned, exiting with status code of $exit_code"
  return $exit_code
}

function is_lvm_lv {
  block="$(realpath $1)"
  lvs="$(lvdisplay -c | egrep -o '/.*' | cut -s -d ':' -f 1)"

  for lv in $lvs; do
    if [ "$(realpath $lv)" = "$block" ]; then
      echo "true"
      return 0
    fi
  done

  echo "false"
}

function install {
  local image_name="$1"
  local initramfs_dest="$2"
  local rootfs_dest="$3"
  local real_rootfs_dest="$(realpath $3)"
  local resize_lvm="$4"
  local force="$5"

  log_info "starting install of $image_name image"

  log_info "creating container for install..."
  local ctr=$(buildah from --device $real_rootfs_dest:$real_rootfs_dest:rw "$image_name")
  log_info "container $ctr created"

  # Clean container on error
  trap "clean_install $ctr" EXIT

  log_info "mounting container fs..."
  local ctr_rootfs=$(buildah mount "$ctr")
  log_info "container fs mounted"

  # Getting kernel version
  kver="$(uname -srm | cut -d ' ' -f 2 || true)"
  if [ "$kver" = "" ]; then
    kver="UNDETERMINED"
  fi

  # Install initramfs
  if [ "$initramfs_dest" != "" ]; then
    log_info "generating initramfs at $initramfs_dest..."
    mkdir -p "$ctr_rootfs/$initramfs_dest"
    buildah run \
      --env HOSTNAME="$image_name" \
      --volume $initramfs_dest:/boot \
      --volume /lib/modules:/lib/modules:ro \
      "$ctr" "/bin/sh" "-c" "KVER=$kver IMAGE_NAME=$image_name /eli/mkinitramfs" > >(log_pipe "[BUILDAH] [INITRAMFS] %s") 2>&1
    log_info "initramfs generated"
  else
    log_info "skipping initramfs generation"
  fi

  log_info "adding grub entry..."
  log_info "grub entry added"

  # Create squashfs
  if [ "$rootfs_dest" != "" ]; then
    if [ "$resize_lvm" = "true" ] && [ "$(is_lvm_lv $rootfs_dest)" = "true" ]; then
      log_info "expanding rootfs logical volume..."
      lvresize --quiet --yes $([ "$force" = "true" ] && echo "-f") \
        --extents +100%FREE $rootfs_dest || true
      log_info "rootfs logical volume expanded"
    fi

    log_info "installing root filesystem on $rootfs_dest..."
    buildah run \
      "$ctr" "/bin/sh" "-c" "mksquashfs / $real_rootfs_dest -noappend -e /proc /sys /run /dev" > >(log_pipe "[BUILDAH] [FSTAB] %s") 2>&1
    log_info "root filesystem installed"

    if [ "$resize_lvm" = "true" ] && [ "$(is_lvm_lv $rootfs_dest)" = "true" ]; then
      log_info "shrinking rootfs logical volume..."
      tmpdir="$(mktemp -d)"

      mount "$rootfs_dest" "$tmpdir"
      local size="$(df -h | tail -n +2 | tr -s ' ' | grep "$rootfs_dest" | cut -d ' ' -f 3)"
      umount -l "$tmpdir"

      lvresize --quiet --yes $([ "$force" = "true" ] && echo "-f") \
        --size $size $rootfs_dest || true
      log_info "rootfs logical volume shrinked"
    fi
  else
    log_info "skipping root filesystem installation"
  fi
}

function main {
  if [ $# -eq 0 ]; then
    log_error "no image or option specified"
    print_help
    stacktrace="false"
    exit 1
  fi


  declare -A images

  # Parse images
  while [ $# -gt 0 ]; do
    case "$1" in
      -*|--*)
        break
        ;;
      
      *)
        images["$1"]=""
        shift
        ;;
    esac
  done

  local rootfs_dest=""
  local initramfs_dest="/boot"
  local resize_lvm="true"
  local force="false"

  # Parse options
  while [ $# -gt 0 ]; do
    case "$1" in
      -h|--help)
        print_help
        exit 0
        ;;

      -i|--initramfs-dest)
        shift
        initramfs_dest="$1"
        if [ $# -eq 0 ]; then
          log_error "missing --initramfs-dest option value"
          stacktrace="false"
          exit 1
        fi
        shift
        ;;

      -d|--rootfs-dest)
        shift
        rootfs_dest="$1"
        if [ $# -eq 0 ]; then
          log_error "missing --rootfs-dest option value"
          stacktrace="false"
          exit 1
        fi

        shift
        ;;

      -l|--resize-lvm)
        shift
        resize_lvm="false"
        ;;

      -f|--force)
        shift
        force="true"
        ;;

      *)
        log_error "unknown option \"$1\""
        stacktrace="false"
        exit 1
        ;;
    esac
  done

  if [ "$initramfs_dest" != "" ] && [ ! -d "$initramfs_dest" ]; then
    log_error "$initramfs_dest: no such directory"
    stacktrace="false"
    exit 1
  fi

  # Ensure rootfs block device file exist
  if [ "$rootfs_dest" != "" ] && [ ! -b  "$rootfs_dest" ]; then
    log_error "$rootfs_dest: no such block device"
    stacktrace="false"
    exit 1
  fi

  # Ask for root permissions if not root
  if [ "$EUID" != "0" ]; then
    log_error "install require root permissions"
    stacktrace="false"
    exit 1
  fi

  for image in ${!images[@]}; do
    install "$image" "$initramfs_dest" "$rootfs_dest" "$resize_lvm" "$force"
  done
}

main "$@"